# 为什么我不选择schedule？

> 本人水平有限，仅探讨通用场景。如有冲突，以你为准。

## 一、引言

我们在使用`Python3`部署定时任务时，通常会选择`schedule`这个轻量级的定时任务调度库。诚然，使用该库实现定时任务遵循“低代码”原则，用不到5行的代码就能实现需求。但本人在最近的项目开发中发现`schedule`并不适用于某些特殊场景的应用场景，并在一波调研后，最终选择了功能更加强大的`apscheduler`调度定时任务。

本文将简要对比两个库在实现同一需求时的优劣，并简要描述两种部署方案的特性，最后作出总结。

## 二、schedule特性

### 2.1 简洁的使用规则

```python
import schedule
import time

def job():
    print('job at work')

if __name__ == '__main__':
	schedule.every(1).second.do(job)
    while True:
        schedule.run_pending()
        time.sleep(1)
```

使用`schedule`实现`interval`间隔触发任务，仅需不足5行的核心代码就能实现需求。

### 2.2 默认阻塞主线程

在上文所述的应用场景中，审敛任务状态使用了`while True`的死循环，这将导致此条调用线路处于无异常则无法正常回调的状态。在主程序不开启多余进程或线程来调用该模块时，程序将陷入这个定时模块的调度模式中。

可见，如果你是冲着`schedule`的简洁性来的，一般只会在单个`.py`文件中直接使用（**这个程序应仅负责定时任务，而不是作为一个庞大系统中的一个模块**）。

### 2.3 简洁高效不可兼得

在上文所述的应用场景中，我们足以一窥`schedule`的简洁。但若使用场景稍微复杂一些，比如引入并发通信，或者存在可能严重超时的定时任务，就会引发**任务阻塞**问题。



## 你是如果案，

## 四、结论



